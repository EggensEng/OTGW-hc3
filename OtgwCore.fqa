{
  "name": "OtgwCore",
  "type": "com.fibaro.genericDevice",
  "apiVersion": "1.2",
  "initialProperties": {
    "viewLayout": {
      "$jason": {
        "body": {
          "header": {
            "style": {
              "height": "0"
            },
            "title": "quickApp_device_56"
          },
          "sections": {
            "items": []
          }
        },
        "head": {
          "title": "quickApp_device_56"
        }
      }
    },
    "uiCallbacks": [],
    "quickAppVariables": [
      {
        "name": "TCP_IP",
        "type": "string",
        "value": "0.0.0.0"
      },
      {
        "name": "TCP_Port",
        "type": "string",
        "value": "0"
      },
      {
        "name": "devicesMap",
        "type": "string",
        "value": [
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121
        ]
      },
      {
        "name": "PrevSetManualRoomSetpoint",
        "type": "string",
        "value": "0.0"
      }
    ],
    "typeTemplateInitialized": true
  },
  "files": [
    {
      "name": "main",
      "isMain": true,
      "isOpen": true,
      "content": "--\n-- QuickApp for the Fibaro HC3\n-- This QuickApp will take care of the OpenTherm Gateway product from: https://otgw.tclcode.com/\n-- QuickApp source: https://github.com/EggensEng/OTGW-hc3\n--\n\n-- Initialize the plugin\nfunction QuickApp:onInit()\n    self:debug(\"Starting OtgwCore\")\n\n    --Definitions of the index for devices\n    self.DevIndexOTGWConnected = 1\n    self.DevIndexWaterPressure = 2\n    self.DevIndexRoomTemperature = 3\n    self.DevIndexRoomSetpoint = 4\n    self.DevIndexRoomSetpointRemote = 5\n    self.DevIndexBoilerWaterTemp = 6\n    self.DevIndexControlSetpoint = 7\n    self.DevIndexFaultIndication = 8\n    self.DevIndexCHMode = 9\n    self.DevIndexDHWMode = 10\n    self.DevIndexFlameStatus = 11\n    self.DevIndexErrorCode = 12\n    self.DevIndexRemoteOverride = 13\n\n    --Initialize the device array\n    self.devicesMap={}\n    self.devicesMap = self:getVariable(\"devicesMap\")\n    self.devicesMap[0] = nil\n    self:setVariable(\"PrevSetManualRoomSetpoint\", 0.0)\n\n-- DEVICES --\n-- OTGW connected[on/off], com.fibaro.binarySensor\n-- Water pressure[bar], Msg 18, com.fibaro.multilevelSensor\n-- Room temperature[C], Msg 24, com.fibaro.temperatureSensor\n-- Room setpoint [C], Msg 16, com.fibaro.hvacSystemAuto\n-- Room setpoint remote[C], Msg 9, com.fibaro.temperatureSensor\n-- Boiler water temp.[C], Msg 25, com.fibaro.temperatureSensor\n-- Control setpoint[C], Msg 1, com.fibaro.temperatureSensor\n-- OEM fault code[num], Msg 5, byte 2, com.fibaro.multilevelSensor\n-- Fault indication[on/off], Msg 0, byte 2, bit 0, com.fibaro.binarySensor\n-- CH mode[on/off], Msg 0, byte 2, bit 1, com.fibaro.binarySensor\n-- DHW mode[on/off], Msg 0, byte 2, bit 2, com.fibaro.binarySensor\n-- Flame status[on/off], Msg 0, byte 2, bit 3, com.fibaro.binarySensor\n-- Remote override[on/off], Msg 100, byte 1 bit 0 and byte 2 bit 0, com.fibaro.binarySensor\n\n    -- Initialize the child devices\n    local function createChildIfNeeded(deviceIndex, deviceType, deviceName)\n        local stat, ret = pcall(checkDevice, self.devicesMap[deviceIndex], deviceType)\n        if stat == false or ret <= 0 then\n            self:createChild(deviceName, deviceType, deviceIndex)\n        end\n    end\n\n    -- OTGW connected[on/off], com.fibaro.binarySensor\n    createChildIfNeeded(self.DevIndexOTGWConnected, \"com.fibaro.binarySensor\", \"OTGW Connected\")\n    -- Water pressure[bar], Msg 18, com.fibaro.multilevelSensor\n    createChildIfNeeded(self.DevIndexWaterPressure, \"com.fibaro.multilevelSensor\", \"Water Pressure\")\n    -- Room temperature[C], Msg 24, com.fibaro.temperatureSensor\n    createChildIfNeeded(self.DevIndexRoomTemperature, \"com.fibaro.temperatureSensor\", \"Room Temperature\")\n    -- Room setpoint [C], Msg 16, com.fibaro.hvacSystemAuto\n    createChildIfNeeded(self.DevIndexRoomSetpoint, \"com.fibaro.hvacSystemAuto\", \"Room Setpoint\")\n    -- Room setpoint remote[C], Msg 9, com.fibaro.temperatureSensor\n    createChildIfNeeded(self.DevIndexRoomSetpointRemote, \"com.fibaro.temperatureSensor\", \"Room Setpoint Remote\")\n    -- Boiler water temp.[C], Msg 25, com.fibaro.temperatureSensor\n    createChildIfNeeded(self.DevIndexBoilerWaterTemp, \"com.fibaro.temperatureSensor\", \"Boiler Water Temp\")\n    -- Control setpoint[C], Msg 1, com.fibaro.temperatureSensor\n    createChildIfNeeded(self.DevIndexControlSetpoint, \"com.fibaro.temperatureSensor\", \"Control Setpoint\")\n    -- Fault indication[on/off], Msg 0, byte 2, bit 0, com.fibaro.binarySensor\n    createChildIfNeeded(self.DevIndexFaultIndication, \"com.fibaro.binarySensor\", \"Fault Indication\")\n    -- CH mode[on/off], Msg 0, byte 2, bit 1, com.fibaro.binarySensor\n    createChildIfNeeded(self.DevIndexCHMode, \"com.fibaro.binarySensor\", \"CH Mode\")\n    -- DHW mode[on/off], Msg 0, byte 2, bit 2, com.fibaro.binarySensor\n    createChildIfNeeded(self.DevIndexDHWMode, \"com.fibaro.binarySensor\", \"DHW Mode\")\n    -- Flame status[on/off], Msg 0, byte 2, bit 3, com.fibaro.binarySensor\n    createChildIfNeeded(self.DevIndexFlameStatus, \"com.fibaro.binarySensor\", \"Flame Status\")\n    -- OEM fault code[num], Msg 5, byte 2, com.fibaro.multilevelSensor\n    createChildIfNeeded(self.DevIndexErrorCode, \"com.fibaro.multilevelSensor\", \"Error code\")\n    -- Remote override[on/off], Msg 100, byte 1 bit 0 and byte 2 bit 0, com.fibaro.binarySensor\n    createChildIfNeeded(self.DevIndexRemoteOverride, \"com.fibaro.binarySensor\", \"Remote override\")\n\n    -- Setup classes for child devices\n    self:initChildDevices({\n        [\"com.fibaro.binarySensor\"] = OtgwDevice,\n        [\"com.fibaro.multilevelSensor\"] = OtgwDevice,\n        [\"com.fibaro.temperatureSensor\"] = OtgwDevice,\n        [\"com.fibaro.hvacSystemAuto\"] = OtgwDevice,\n        [\"com.fibaro.temperatureSensor\"] = OtgwDevice,\n        [\"com.fibaro.temperatureSensor\"] = OtgwDevice,\n        [\"com.fibaro.temperatureSensor\"] = OtgwDevice,\n        [\"com.fibaro.binarySensor\"] = OtgwDevice,\n        [\"com.fibaro.binarySensor\"] = OtgwDevice,\n        [\"com.fibaro.binarySensor\"] = OtgwDevice,\n        [\"com.fibaro.binarySensor\"] = OtgwDevice,\n        [\"com.fibaro.multilevelSensor\"] = OtgwDevice,\n        [\"com.fibaro.binarySensor\"] = OtgwDevice,\n    })\n\n    -- Print all child devices.\n    for id,device in pairs(self.childDevices) do\n        self:debug(\"Load child device: [\", id, \"]\", device.name, \", type of: \", device.type)\n    end\n\n    -- Set properties for devices\n    fibaro.call(self.devicesMap[self.DevIndexWaterPressure], \"setUnit\", \"Bar\")\n    fibaro.call(self.devicesMap[self.DevIndexErrorCode], \"setUnit\", \"#\")\n    fibaro.call(self.devicesMap[self.DevIndexOTGWConnected], \"setBinary\", tostring(0))\n\n    -- Initialize TCP socket\n    self.sock = net.TCPSocket()\n    self:connect()\nend\n\n-- Used in combination with pcal to check if a device exist\nfunction checkDevice(deviceId, deviceType)\n    if hub.getType(deviceId) ~= deviceType then\n        return 0\n    else\n        return 1\n    end\nend\n\n-- Initialize the opentherm gateway when the connection is made\nfunction QuickApp:initOtgwDevice()\n\n    -- Set DHW to economy mode.\n    sendData = \"HW=0\\r\"\n    self:send(sendData)\nend\n\n-- Handler for all data reveiced from the OpenTherm Gateway\nfunction QuickApp:handleOtgwData(dataMessage)\n    -- Define a pattern to match groups of non-space characters\n    local patternMessage = \"%S+\"\n    -- Initialize an empty table to store the components\n    local componentsMessage = {}\n    -- Iterate over the matches and insert them into the table\n    for match in string.gmatch(dataMessage, patternMessage) do\n        table.insert(componentsMessage, match)\n    end\n\n    --Handle manual thermostat setpoint\n    prevManualSetpoint = self:getVariable(\"PrevSetManualRoomSetpoint\")\n    actualManualSetpoint = fibaro.getValue(self.devicesMap[self.DevIndexRoomSetpoint], \"heatingThermostatSetpoint\")\n    if( tostring(prevManualSetpoint) ~= \"0.0\" and tostring(actualManualSetpoint) ~= tostring(prevManualSetpoint) ) then\n        self:debug(\"Setting new setpoint \", prevManualSetpoint, actualManualSetpoint)\n        sendData1 = \"TC=\" .. tostring(actualManualSetpoint) .. \"0\\r\"\n        sendData2 = \"TT=\" .. tostring(actualManualSetpoint) .. \"0\\r\"\n        self:debug(\"Sending setpoint 1: \", sendData1)\n        self:debug(\"Sending setpoint 2: \", sendData2)\n        self:send(sendData1)--Send command to thermostat for changing setpoint\n        self:send(sendData2)--Send command to thermostat for changing setpoint\n        self:setVariable(\"PrevSetManualRoomSetpoint\", actualManualSetpoint)\n    end\n\n    for iMessage, valueMessage in ipairs(componentsMessage) do\n        --Split received message\n        MsgSrc = valueMessage:sub(1,1)\n        MsgType = string.toint(valueMessage:sub(2,3))\n        MsgId = string.toint(valueMessage:sub(4,5))\n        MsgDat1 = string.toint(valueMessage:sub(6,7))\n        MsgDat2 = string.toint(valueMessage:sub(8,9))\n        FrameReadAck = (MsgType & 0x40)\n        FrameWriteDat = (MsgType & 0x10)\n        FrameWriteAck = (MsgType & 0x50)\n\n        --Handle received messages\n        if (FrameReadAck>0 or FrameWriteAck>0) then\n            -- Water pressure[bar], Msg 18, com.fibaro.multilevelSensor\n            if MsgId == 18 then -- Actual pressure of the water system\n                fibaro.call(self.devicesMap[self.DevIndexWaterPressure], \"setValue\", string.tofloat16(valueMessage:sub(6,9)))\n\n            -- Room temperature[C], Msg 24, com.fibaro.temperatureSensor\n            elseif MsgId == 24 then\n                fibaro.call(self.devicesMap[self.DevIndexRoomTemperature], \"setValue\", string.tofloat16(valueMessage:sub(6,9)))\n\n            -- Room setpoint [C], Msg 16, com.fibaro.hvacSystemAuto\n            elseif MsgId == 16 then\n                DataConvert = tostring(string.tofloat16(valueMessage:sub(6,9)))\n                fibaro.call(self.devicesMap[self.DevIndexRoomSetpoint], \"setHeatingThermostatSetpoint\", DataConvert)\n                self:setVariable(\"PrevSetManualRoomSetpoint\", DataConvert)\n                self:debug(\"Receiving new setpoint \", DataConvert)\n\n            -- Room setpoint remote[C], Msg 9, com.fibaro.temperatureSensor\n            elseif MsgId == 9 then\n                fibaro.call(self.devicesMap[self.DevIndexRoomSetpointRemote], \"setValue\", tostring(string.tofloat16(valueMessage:sub(6,9))))\n\n            -- Boiler water temp.[C], Msg 25, com.fibaro.temperatureSensor\n            elseif MsgId == 25 then\n                fibaro.call(self.devicesMap[self.DevIndexBoilerWaterTemp], \"setValue\", tostring(string.tofloat16(valueMessage:sub(6,9))))\n\n            -- Control setpoint[C], Msg 1, com.fibaro.temperatureSensor\n            elseif MsgId == 1 then\n                fibaro.call(self.devicesMap[self.DevIndexControlSetpoint], \"setValue\", tostring(string.tofloat16(valueMessage:sub(6,9))))\n\n            -- Fault indication[on/off], Msg 0, byte 2, bit 0, com.fibaro.binarySensor\n            -- CH mode[on/off], Msg 0, byte 2, bit 1, com.fibaro.binarySensor\n            -- DHW mode[on/off], Msg 0, byte 2, bit 2, com.fibaro.binarySensor\n            -- Flame status[on/off], Msg 0, byte 2, bit 3, com.fibaro.binarySensor\n            elseif MsgId == 0 then\n                fibaro.call(self.devicesMap[self.DevIndexFaultIndication], \"setBinary\", tostring(MsgDat2&0x01))\n                fibaro.call(self.devicesMap[self.DevIndexCHMode], \"setBinary\", tostring(MsgDat2&0x02))\n                fibaro.call(self.devicesMap[self.DevIndexDHWMode], \"setBinary\", tostring(MsgDat2&0x04))\n                fibaro.call(self.devicesMap[self.DevIndexFlameStatus], \"setBinary\", tostring(MsgDat2&0x08))\n\n            -- OEM fault code[num], Msg 5, byte 2, com.fibaro.multilevelSensor\n            elseif MsgId == 5 then\n                fibaro.call(self.devicesMap[self.DevIndexErrorCode], \"setValue\", MsgDat2)\n\n            -- Remote override[on/off], Msg 100, byte 1 bit 0 and byte 2 bit 0, com.fibaro.binarySensor\n            elseif MsgId == 100 then\n                fibaro.call(self.devicesMap[self.DevIndexRemoteOverride], \"setBinary\", tostring((MsgDat1&0x01) and (MsgDat2&0x01)))\n            end\n        end\n    end\nend"
    },
    {
      "name": "OtgwDevice",
      "isMain": false,
      "isOpen": true,
      "content": "--\n-- Class for OTGW device that will be used on creating new child deviced in use for the plugin\n--\n\n-- OpenthermGateway child device class\nclass 'OtgwDevice' (QuickAppChild)\n    function OtgwDevice:__init(device)\n        QuickAppChild.__init(self, device)\n    \n        -- setup default values for a thermostat\n        self:updateProperty(\"supportedThermostatModes\", {\"Heat\"})\n        self:updateProperty(\"thermostatMode\", \"Heat\")\n        self:updateProperty(\"heatingThermostatSetpoint\", 15)\n    end\n\n    function OtgwDevice:setBinary(value)\n        if tonumber(value) and tonumber(value) > 0 then\n            self:updateProperty(\"value\", true)\n        else\n            self:updateProperty(\"value\", false)\n        end\n    end\n\n    function OtgwDevice:setValue(value)\n        self:updateProperty(\"value\", value)\n    end\n\n    function OtgwDevice:setUnit(unit)\n        self:updateProperty(\"unit\", unit)\n    end\n\n    -- handle action for mode change\n    function OtgwDevice:setThermostatMode(mode)\n        self:updateProperty(\"thermostatMode\", mode)\n    end\n\n    -- handle action for setting set point for heating\n    function OtgwDevice:setHeatingThermostatSetpoint(value) \n        self:updateProperty(\"heatingThermostatSetpoint\", value)\n    end\n\n    -- handle action for setting set point for cooling\n    function OtgwDevice:setCoolingThermostatSetpoint(value)\n        self:updateProperty(\"setCoolingThermostatSetpoint\", value)\n    end"
    },
    {
      "name": "TCP",
      "isMain": false,
      "isOpen": true,
      "content": "--\n-- All functions that are related to TCP/IP communication\n--\n\n-- Attempt a (re-)connection via TCP/IP\nfunction QuickApp:connect()\n    local ip = self:getVariable(\"TCP_IP\")\n    local port = tonumber(self:getVariable(\"TCP_Port\"))\n\n    -- Set a check variable for communication active\n    self.connectionActive = 1\n\n    self.sock:connect(ip, port, { -- connection to the device with the specified IP and port\n        success = function() -- the function will be triggered if the connection is correct\n            self:debug(\"connected\")\n            self:initOtgwDevice()\n            self:checkConnection()\n            self:waitForResponseFunction() -- launching a data readout \"loop\"\n        end,\n        error = function(err) -- a function that will be triggered in case of an incorrect connection, e.g. timeout\n            self:debug(\"connection error\")\n            fibaro.setTimeout(5000, function() self:connect() end) -- re-connection attempt (every 5s)\n        end,\n    })\nend\n\n-- Cyclic re-check if the connection is still active\nfunction QuickApp:checkConnection()\n    if self.connectionActive == 1 then\n        self.connectionActive = 0\n        --self:debug(\"connection active\")\n        fibaro.call(self.devicesMap[self.DevIndexOTGWConnected], \"setBinary\", tostring(1))\n        fibaro.setTimeout(10000, function() self:checkConnection() end)\n    elseif self.connectionActive == 0 then\n        --self:debug(\"connection lost\")\n        fibaro.call(self.devicesMap[self.DevIndexOTGWConnected], \"setBinary\", tostring(0))\n        self:connect()\n    end\nend\n\n-- Cyclic re-check if there is new data to receive\nfunction QuickApp:waitForResponseFunction()\n    self.sock:read({ -- reading a data package from the socket\n        success = function(data)\n            self.connectionActive = 1\n            self:onDataReceived(data) -- handling of received data\n            self:waitForResponseFunction() -- looping of data readout\n        end,\n        error = function() -- a function that will be called in case of an error when trying to receive data, e.g. disconnecting a socket\n            self:debug(\"response error at receiving\")\n            self.connectionActive = 0\n        end\n    })\nend\n\n-- Send new data on the communication socket if active\nfunction QuickApp:send(strToSend)\n    self.sock:write(strToSend, {\n        success = function() -- the function that will be triggered when the data is correctly sent\n            --self:debug(\"data sent:\", strToSend)\n        end,\n        error = function(err) -- the function that will be triggered in the event of an error in data transmission\n            self:debug(\"error while sending data\")\n        end\n    })\nend\n\n-- Called when new data is received\nfunction QuickApp:onDataReceived(data)\n    self:handleOtgwData(data)\nend"
    },
    {
      "name": "Child",
      "isMain": false,
      "isOpen": true,
      "content": "--\n-- Child device creation functions\n--\n\n-- Create a new child device\nfunction QuickApp:createChild(name, type, uid, className)\n    local child = self:createChildDevice({\n        name = name,\n        type = type,\n    }, OtgwDevice)\n\n    self:trace(\"Child device created: \", child.id)\n\n    -- Store child device ID in device map\n    self.devicesMap[uid] = child.id\n    self:setVariable(\"devicesMap\", self.devicesMap)\nend"
    },
    {
      "name": "Conversions",
      "isMain": false,
      "isOpen": true,
      "content": "--\n-- Collection of functions related to conversion of data\n--\n\n-- Convert 4 characters that is represented in HEX to a float\n-- Input: string\n-- Return: Float\nfunction string.tofloat16(hexBytesString)\n    local intH = string.toint(hexBytesString:sub(1,2))\n    local intL = string.toint(hexBytesString:sub(3,4))\n    return ((intH<<8) + intL) / 256.0\nend\n\n-- Convert 2 characters that is represented in HEX to an int\n-- Input: string\n-- Return: Int\nfunction string.toint(charHL)\n    local intH = string.tointSingle(charHL:sub(1,1))\n    local intL = string.tointSingle(charHL:sub(2,2))\n    return (intH << 4) + intL\nend\n\n\n-- Convert 1 character that is represented in HEX to an int\n-- Input: string\n-- Return: Int\nfunction string.tointSingle(char1)\n    if char1 == \"0\" then\n        return 0\n    end\n\n    local num = tonumber(char1)\n    if num == nil then\n    else\n        if num > 0 or num < 10 then\n            return num\n        end\n    end\n    \n    if char1 == \"A\" then\n        return 10\n    elseif char1 == \"B\" then\n        return 11\n    elseif char1 == \"C\" then\n        return 12\n    elseif char1 == \"D\" then\n        return 13\n    elseif char1 == \"E\" then\n        return 14\n    elseif char1 == \"F\" then\n        return 15\n    end\n\n    return 0\nend"
    }
  ]
}
